use std::{
    rc::Rc,
    sync::atomic::{AtomicUsize, Ordering},
};

use crate::{expression::Expression, scope::Context};
use proc_macro2::Span;
use quote::format_ident;
use syn::{
    spanned::Spanned, Ident, Index, Member, Pat, PatStruct, PatTuple, PatTupleStruct, Stmt, Type,
    TypeReference,
};

#[derive(Clone, Debug)]
pub enum Statement {
    Local {
        left: Box<Expression>,
        init: Option<Box<Expression>>,
        mutable: bool,
        ty: Option<Type>,
    },
    /// Group of statements generated by desugaring
    Group {
        statements: Vec<Statement>,
    },
    Expression {
        expression: Box<Expression>,
        terminated: bool,
        span: Span,
    },
    Skip,
}

impl Statement {
    pub fn from_stmt(stmt: Stmt, context: &mut Context) -> syn::Result<Self> {
        let statement = match stmt {
            Stmt::Local(local) => {
                let init = local
                    .init
                    .map(|init| Expression::from_expr(*init.expr, context))
                    .transpose()?
                    .map(Box::new);
                let Pattern {
                    ident,
                    ty,
                    is_ref,
                    is_mut,
                } = match local.pat {
                    Pat::Struct(pat) => {
                        return desugar_struct_local(pat, *init.unwrap(), context);
                    }
                    Pat::Tuple(PatTuple { elems, .. })
                    | Pat::TupleStruct(PatTupleStruct { elems, .. }) => {
                        return desugar_tuple_local(elems, *init.unwrap(), context)
                    }
                    pat => parse_pat(pat)?,
                };
                let is_const = init.as_ref().map(|init| init.is_const()).unwrap_or(false);
                let variable = Box::new(Expression::Variable {
                    name: ident.clone(),
                    is_ref,
                    is_mut,
                    ty: ty.clone(),
                    use_count: Rc::new(AtomicUsize::new(0)),
                });

                context.push_variable(ident, ty.clone(), is_const && !is_mut, is_ref, is_mut);
                Self::Local {
                    left: variable,
                    init,
                    mutable: is_mut,
                    ty,
                }
            }
            Stmt::Expr(expr, semi) => {
                let span = expr.span();
                let expression = Box::new(Expression::from_expr(expr, context)?);
                Statement::Expression {
                    terminated: semi.is_some() || !expression.needs_terminator(),
                    span,
                    expression,
                }
            }
            Stmt::Item(_) => Statement::Skip,
            stmt => Err(syn::Error::new_spanned(stmt, "Unsupported statement"))?,
        };
        Ok(statement)
    }
}

pub struct Pattern {
    pub ident: Ident,
    pub ty: Option<Type>,
    pub is_ref: bool,
    pub is_mut: bool,
}

pub fn parse_pat(pat: Pat) -> syn::Result<Pattern> {
    let res = match pat {
        Pat::Ident(ident) => Pattern {
            ident: ident.ident,
            ty: None,
            is_ref: ident.by_ref.is_some(),
            is_mut: ident.mutability.is_some(),
        },
        Pat::Type(pat) => {
            let ty = *pat.ty;
            let is_ref = matches!(ty, Type::Reference(_));
            let ref_mut = matches!(
                ty,
                Type::Reference(TypeReference {
                    mutability: Some(_),
                    ..
                })
            );
            let inner = parse_pat(*pat.pat)?;
            Pattern {
                ident: inner.ident,
                ty: Some(ty),
                is_ref: is_ref || inner.is_ref,
                is_mut: ref_mut || inner.is_mut,
            }
        }
        Pat::Wild(_) => Pattern {
            ident: format_ident!("_"),
            ty: None,
            is_ref: false,
            is_mut: false,
        },
        pat => Err(syn::Error::new_spanned(
            pat.clone(),
            format!("Unsupported local pat: {pat:?}"),
        ))?,
    };
    Ok(res)
}

fn desugar_struct_local(
    pat: PatStruct,
    init: Expression,
    context: &mut Context,
) -> syn::Result<Statement> {
    let fields = pat
        .fields
        .into_iter()
        .map(|field| {
            let span = field.span();
            let access = Expression::FieldAccess {
                base: Box::new(init.clone()),
                field: field.member,
                span,
            };
            let Pattern {
                ident,
                ty,
                is_ref,
                is_mut,
            } = parse_pat(*field.pat.clone())?;
            context.push_variable(ident.clone(), ty.clone(), init.is_const(), is_ref, is_mut);
            let statement = Statement::Local {
                left: Box::new(Expression::Variable {
                    name: ident,
                    is_ref,
                    is_mut,
                    ty: ty.clone(),
                    use_count: AtomicUsize::new(0).into(),
                }),
                init: Some(Box::new(access)),
                mutable: is_mut,
                ty,
            };
            Ok(statement)
        })
        .collect::<syn::Result<Vec<_>>>()?;

    match init {
        Expression::Variable { use_count, .. } | Expression::ConstVariable { use_count, .. } => {
            use_count.fetch_add(fields.len() - 1, Ordering::AcqRel);
        }
        _ => {}
    }

    Ok(Statement::Group { statements: fields })
}

fn desugar_tuple_local(
    elems: impl IntoIterator<Item = Pat>,
    init: Expression,
    context: &mut Context,
) -> syn::Result<Statement> {
    let fields = elems
        .into_iter()
        .enumerate()
        .map(|(i, pat)| {
            let span = pat.span();
            let access = Expression::FieldAccess {
                base: Box::new(init.clone()),
                field: Member::Unnamed(Index::from(i)),
                span,
            };
            let Pattern {
                ident,
                ty,
                is_ref,
                is_mut,
            } = parse_pat(pat.clone())?;
            context.push_variable(ident.clone(), ty.clone(), init.is_const(), is_ref, is_mut);
            let statement = Statement::Local {
                left: Box::new(Expression::Variable {
                    name: ident,
                    ty: ty.clone(),
                    use_count: AtomicUsize::new(0).into(),
                    is_ref,
                    is_mut,
                }),
                init: Some(Box::new(access)),
                mutable: is_mut,
                ty,
            };
            Ok(statement)
        })
        .collect::<syn::Result<Vec<_>>>()?;

    match init {
        Expression::Variable { use_count, .. } | Expression::ConstVariable { use_count, .. } => {
            use_count.fetch_add(fields.len() - 1, Ordering::AcqRel);
        }
        _ => {}
    }

    Ok(Statement::Group { statements: fields })
}
